/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import * as nestAccessControl from "nest-access-control";
import * as defaultAuthGuard from "../../auth/defaultAuth.guard";
import { AssetService } from "../asset.service";
import { AclValidateRequestInterceptor } from "../../interceptors/aclValidateRequest.interceptor";
import { AclFilterResponseInterceptor } from "../../interceptors/aclFilterResponse.interceptor";
import { AssetCreateInput } from "./AssetCreateInput";
import { Asset } from "./Asset";
import { AssetFindManyArgs } from "./AssetFindManyArgs";
import { AssetWhereUniqueInput } from "./AssetWhereUniqueInput";
import { AssetUpdateInput } from "./AssetUpdateInput";
import { ApplicationDeploymentFindManyArgs } from "../../applicationDeployment/base/ApplicationDeploymentFindManyArgs";
import { ApplicationDeployment } from "../../applicationDeployment/base/ApplicationDeployment";
import { ApplicationDeploymentWhereUniqueInput } from "../../applicationDeployment/base/ApplicationDeploymentWhereUniqueInput";
import { AssetConfigurationDetailFindManyArgs } from "../../assetConfigurationDetail/base/AssetConfigurationDetailFindManyArgs";
import { AssetConfigurationDetail } from "../../assetConfigurationDetail/base/AssetConfigurationDetail";
import { AssetConfigurationDetailWhereUniqueInput } from "../../assetConfigurationDetail/base/AssetConfigurationDetailWhereUniqueInput";
import { AssetLocationDetailFindManyArgs } from "../../assetLocationDetail/base/AssetLocationDetailFindManyArgs";
import { AssetLocationDetail } from "../../assetLocationDetail/base/AssetLocationDetail";
import { AssetLocationDetailWhereUniqueInput } from "../../assetLocationDetail/base/AssetLocationDetailWhereUniqueInput";
import { AssetNetworkDetailFindManyArgs } from "../../assetNetworkDetail/base/AssetNetworkDetailFindManyArgs";
import { AssetNetworkDetail } from "../../assetNetworkDetail/base/AssetNetworkDetail";
import { AssetNetworkDetailWhereUniqueInput } from "../../assetNetworkDetail/base/AssetNetworkDetailWhereUniqueInput";
import { AssetSupportDetailFindManyArgs } from "../../assetSupportDetail/base/AssetSupportDetailFindManyArgs";
import { AssetSupportDetail } from "../../assetSupportDetail/base/AssetSupportDetail";
import { AssetSupportDetailWhereUniqueInput } from "../../assetSupportDetail/base/AssetSupportDetailWhereUniqueInput";
import { AttestationHostFindManyArgs } from "../../attestationHost/base/AttestationHostFindManyArgs";
import { AttestationHost } from "../../attestationHost/base/AttestationHost";
import { AttestationHostWhereUniqueInput } from "../../attestationHost/base/AttestationHostWhereUniqueInput";
import { BigfixRequestFindManyArgs } from "../../bigfixRequest/base/BigfixRequestFindManyArgs";
import { BigfixRequest } from "../../bigfixRequest/base/BigfixRequest";
import { BigfixRequestWhereUniqueInput } from "../../bigfixRequest/base/BigfixRequestWhereUniqueInput";
import { DatasourceDeviceFindManyArgs } from "../../datasourceDevice/base/DatasourceDeviceFindManyArgs";
import { DatasourceDevice } from "../../datasourceDevice/base/DatasourceDevice";
import { DatasourceDeviceWhereUniqueInput } from "../../datasourceDevice/base/DatasourceDeviceWhereUniqueInput";
import { ExceptionFindManyArgs } from "../../exception/base/ExceptionFindManyArgs";
import { Exception } from "../../exception/base/Exception";
import { ExceptionWhereUniqueInput } from "../../exception/base/ExceptionWhereUniqueInput";
import { IpAddressFindManyArgs } from "../../ipAddress/base/IpAddressFindManyArgs";
import { IpAddress } from "../../ipAddress/base/IpAddress";
import { IpAddressWhereUniqueInput } from "../../ipAddress/base/IpAddressWhereUniqueInput";
import { MaintenanceWindowFindManyArgs } from "../../maintenanceWindow/base/MaintenanceWindowFindManyArgs";
import { MaintenanceWindow } from "../../maintenanceWindow/base/MaintenanceWindow";
import { MaintenanceWindowWhereUniqueInput } from "../../maintenanceWindow/base/MaintenanceWindowWhereUniqueInput";
import { OperationsCalendarFindManyArgs } from "../../operationsCalendar/base/OperationsCalendarFindManyArgs";
import { OperationsCalendar } from "../../operationsCalendar/base/OperationsCalendar";
import { OperationsCalendarWhereUniqueInput } from "../../operationsCalendar/base/OperationsCalendarWhereUniqueInput";
import { RebootWindowFindManyArgs } from "../../rebootWindow/base/RebootWindowFindManyArgs";
import { RebootWindow } from "../../rebootWindow/base/RebootWindow";
import { RebootWindowWhereUniqueInput } from "../../rebootWindow/base/RebootWindowWhereUniqueInput";
import { SubMgmtChangeLogFindManyArgs } from "../../subMgmtChangeLog/base/SubMgmtChangeLogFindManyArgs";
import { SubMgmtChangeLog } from "../../subMgmtChangeLog/base/SubMgmtChangeLog";
import { SubMgmtChangeLogWhereUniqueInput } from "../../subMgmtChangeLog/base/SubMgmtChangeLogWhereUniqueInput";
import { TssChangeLogFindManyArgs } from "../../tssChangeLog/base/TssChangeLogFindManyArgs";
import { TssChangeLog } from "../../tssChangeLog/base/TssChangeLog";
import { TssChangeLogWhereUniqueInput } from "../../tssChangeLog/base/TssChangeLogWhereUniqueInput";

@swagger.ApiBearerAuth()
@common.UseGuards(defaultAuthGuard.DefaultAuthGuard, nestAccessControl.ACGuard)
export class AssetControllerBase {
  constructor(
    protected readonly service: AssetService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}
  @common.UseInterceptors(AclValidateRequestInterceptor)
  @common.Post()
  @swagger.ApiCreatedResponse({ type: Asset })
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "create",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async createAsset(@common.Body() data: AssetCreateInput): Promise<Asset> {
    return await this.service.createAsset({
      data: {
        ...data,

        endpointManagementSolution: data.endpointManagementSolution
          ? {
              connect: data.endpointManagementSolution,
            }
          : undefined,
      },
      select: {
        altId: true,
        appServerId: true,
        applicationHostId: true,
        assigned: true,
        created: true,
        description: true,

        endpointManagementSolution: {
          select: {
            id: true,
          },
        },

        enterpriseId: true,
        id: true,
        isLocked: true,
        isShared: true,
        note: true,
        systemBackupId: true,
        systemCitrixId: true,
        tag: true,
        updated: true,
        updatedBy: true,
      },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get()
  @swagger.ApiOkResponse({ type: [Asset] })
  @ApiNestedQuery(AssetFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "read",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async assets(@common.Req() request: Request): Promise<Asset[]> {
    const args = plainToClass(AssetFindManyArgs, request.query);
    return this.service.assets({
      ...args,
      select: {
        altId: true,
        appServerId: true,
        applicationHostId: true,
        assigned: true,
        created: true,
        description: true,

        endpointManagementSolution: {
          select: {
            id: true,
          },
        },

        enterpriseId: true,
        id: true,
        isLocked: true,
        isShared: true,
        note: true,
        systemBackupId: true,
        systemCitrixId: true,
        tag: true,
        updated: true,
        updatedBy: true,
      },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: Asset })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "read",
    possession: "own",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async asset(
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<Asset | null> {
    const result = await this.service.asset({
      where: params,
      select: {
        altId: true,
        appServerId: true,
        applicationHostId: true,
        assigned: true,
        created: true,
        description: true,

        endpointManagementSolution: {
          select: {
            id: true,
          },
        },

        enterpriseId: true,
        id: true,
        isLocked: true,
        isShared: true,
        note: true,
        systemBackupId: true,
        systemCitrixId: true,
        tag: true,
        updated: true,
        updatedBy: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return result;
  }

  @common.UseInterceptors(AclValidateRequestInterceptor)
  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: Asset })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async updateAsset(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() data: AssetUpdateInput
  ): Promise<Asset | null> {
    try {
      return await this.service.updateAsset({
        where: params,
        data: {
          ...data,

          endpointManagementSolution: data.endpointManagementSolution
            ? {
                connect: data.endpointManagementSolution,
              }
            : undefined,
        },
        select: {
          altId: true,
          appServerId: true,
          applicationHostId: true,
          assigned: true,
          created: true,
          description: true,

          endpointManagementSolution: {
            select: {
              id: true,
            },
          },

          enterpriseId: true,
          id: true,
          isLocked: true,
          isShared: true,
          note: true,
          systemBackupId: true,
          systemCitrixId: true,
          tag: true,
          updated: true,
          updatedBy: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: Asset })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "delete",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async deleteAsset(
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<Asset | null> {
    try {
      return await this.service.deleteAsset({
        where: params,
        select: {
          altId: true,
          appServerId: true,
          applicationHostId: true,
          assigned: true,
          created: true,
          description: true,

          endpointManagementSolution: {
            select: {
              id: true,
            },
          },

          enterpriseId: true,
          id: true,
          isLocked: true,
          isShared: true,
          note: true,
          systemBackupId: true,
          systemCitrixId: true,
          tag: true,
          updated: true,
          updatedBy: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/applicationDeployment")
  @ApiNestedQuery(ApplicationDeploymentFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "ApplicationDeployment",
    action: "read",
    possession: "any",
  })
  async findApplicationDeployment(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<ApplicationDeployment[]> {
    const query = plainToClass(
      ApplicationDeploymentFindManyArgs,
      request.query
    );
    const results = await this.service.findApplicationDeployment(params.id, {
      ...query,
      select: {
        application: {
          select: {
            id: true,
          },
        },

        asset: {
          select: {
            id: true,
          },
        },

        created: true,
        deploymentId: true,
        deploymentName: true,
        deploymentNote: true,
        deploymentStatus: true,
        deploymentType: true,
        id: true,
        updated: true,
        updatedBy: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/applicationDeployment")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectApplicationDeployment(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: ApplicationDeploymentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      applicationDeployment: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/applicationDeployment")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateApplicationDeployment(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: ApplicationDeploymentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      applicationDeployment: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/applicationDeployment")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectApplicationDeployment(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: ApplicationDeploymentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      applicationDeployment: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/assetConfigurationDetails")
  @ApiNestedQuery(AssetConfigurationDetailFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "AssetConfigurationDetail",
    action: "read",
    possession: "any",
  })
  async findAssetConfigurationDetails(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<AssetConfigurationDetail[]> {
    const query = plainToClass(
      AssetConfigurationDetailFindManyArgs,
      request.query
    );
    const results = await this.service.findAssetConfigurationDetails(
      params.id,
      {
        ...query,
        select: {
          asset: {
            select: {
              id: true,
            },
          },

          assetTag: true,
          bios: true,
          brand: true,
          cpuCount: true,
          cpuSpeed: true,
          cpuType: true,
          cpuVersion: true,
          created: true,
          id: true,
          inService: true,
          lastHardwareScan: true,
          model: true,
          nature: true,
          operatingSystem: true,
          role: true,
          scanExemptReason: true,
          serial: true,
          status: true,
          typeField: true,
          updated: true,
        },
      }
    );
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/assetConfigurationDetails")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectAssetConfigurationDetails(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AssetConfigurationDetailWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      assetConfigurationDetails: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/assetConfigurationDetails")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateAssetConfigurationDetails(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AssetConfigurationDetailWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      assetConfigurationDetails: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/assetConfigurationDetails")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectAssetConfigurationDetails(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AssetConfigurationDetailWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      assetConfigurationDetails: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/assetLocationDetails")
  @ApiNestedQuery(AssetLocationDetailFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "AssetLocationDetail",
    action: "read",
    possession: "any",
  })
  async findAssetLocationDetails(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<AssetLocationDetail[]> {
    const query = plainToClass(AssetLocationDetailFindManyArgs, request.query);
    const results = await this.service.findAssetLocationDetails(params.id, {
      ...query,
      select: {
        asset: {
          select: {
            id: true,
          },
        },

        created: true,
        id: true,
        inDataCenter: true,
        locationBuilding: true,
        locationCode: true,
        locationFloor: true,
        locationFull: true,
        locationGrid: true,
        locationPhysical: true,
        region: true,
        serviceArea: true,
        updated: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/assetLocationDetails")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectAssetLocationDetails(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AssetLocationDetailWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      assetLocationDetails: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/assetLocationDetails")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateAssetLocationDetails(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AssetLocationDetailWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      assetLocationDetails: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/assetLocationDetails")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectAssetLocationDetails(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AssetLocationDetailWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      assetLocationDetails: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/assetNetworkDetails")
  @ApiNestedQuery(AssetNetworkDetailFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "AssetNetworkDetail",
    action: "read",
    possession: "any",
  })
  async findAssetNetworkDetails(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<AssetNetworkDetail[]> {
    const query = plainToClass(AssetNetworkDetailFindManyArgs, request.query);
    const results = await this.service.findAssetNetworkDetails(params.id, {
      ...query,
      select: {
        asset: {
          select: {
            id: true,
          },
        },

        created: true,
        dnsName: true,
        domain: true,
        hostname: true,
        id: true,
        macAddress: true,
        memberOfCluster: true,
        previousHostname: true,
        primaryMacAddress: true,
        updated: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/assetNetworkDetails")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectAssetNetworkDetails(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AssetNetworkDetailWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      assetNetworkDetails: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/assetNetworkDetails")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateAssetNetworkDetails(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AssetNetworkDetailWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      assetNetworkDetails: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/assetNetworkDetails")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectAssetNetworkDetails(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AssetNetworkDetailWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      assetNetworkDetails: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/assetSupportDetails")
  @ApiNestedQuery(AssetSupportDetailFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "AssetSupportDetail",
    action: "read",
    possession: "any",
  })
  async findAssetSupportDetails(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<AssetSupportDetail[]> {
    const query = plainToClass(AssetSupportDetailFindManyArgs, request.query);
    const results = await this.service.findAssetSupportDetails(params.id, {
      ...query,
      select: {
        activityBasedCosting: true,

        asset: {
          select: {
            id: true,
          },
        },

        assetSupportVendor: {
          select: {
            id: true,
          },
        },

        created: true,
        id: true,
        resourceUnitId: true,
        supportContractEndDate: true,
        supportContractId: true,
        supportContractRenewalCost: true,
        supportContractRenewalDate: true,
        supportContractRenewalNotes: true,
        supportContractRenewalTerm: true,
        supportContractStartDate: true,
        updated: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/assetSupportDetails")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectAssetSupportDetails(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AssetSupportDetailWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      assetSupportDetails: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/assetSupportDetails")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateAssetSupportDetails(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AssetSupportDetailWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      assetSupportDetails: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/assetSupportDetails")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectAssetSupportDetails(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AssetSupportDetailWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      assetSupportDetails: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/attestationHost")
  @ApiNestedQuery(AttestationHostFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "AttestationHost",
    action: "read",
    possession: "any",
  })
  async findAttestationHost(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<AttestationHost[]> {
    const query = plainToClass(AttestationHostFindManyArgs, request.query);
    const results = await this.service.findAttestationHost(params.id, {
      ...query,
      select: {
        asset: {
          select: {
            id: true,
          },
        },

        attestation: {
          select: {
            id: true,
          },
        },

        created: true,
        id: true,
        isSupportedByThirdParty: true,
        updated: true,
        updatedBy: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/attestationHost")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectAttestationHost(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AttestationHostWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      attestationHost: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/attestationHost")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateAttestationHost(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AttestationHostWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      attestationHost: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/attestationHost")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectAttestationHost(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: AttestationHostWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      attestationHost: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/bigfixRequest")
  @ApiNestedQuery(BigfixRequestFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "BigfixRequest",
    action: "read",
    possession: "any",
  })
  async findBigfixRequest(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<BigfixRequest[]> {
    const query = plainToClass(BigfixRequestFindManyArgs, request.query);
    const results = await this.service.findBigfixRequest(params.id, {
      ...query,
      select: {
        actionScriptId: true,

        asset: {
          select: {
            id: true,
          },
        },

        bigfixEnvironment: true,

        bigfixRequestType: {
          select: {
            id: true,
          },
        },

        computerId: true,
        computerStatus: true,
        created: true,
        httpResponse: true,
        httpResponseMessage: true,
        id: true,
        request: true,
        requestComputerSettings: true,
        requestStatus: true,
        response: true,
        updated: true,
        updatedBy: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/bigfixRequest")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectBigfixRequest(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: BigfixRequestWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      bigfixRequest: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/bigfixRequest")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateBigfixRequest(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: BigfixRequestWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      bigfixRequest: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/bigfixRequest")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectBigfixRequest(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: BigfixRequestWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      bigfixRequest: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/datasourceDevices")
  @ApiNestedQuery(DatasourceDeviceFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "DatasourceDevice",
    action: "read",
    possession: "any",
  })
  async findDatasourceDevices(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<DatasourceDevice[]> {
    const query = plainToClass(DatasourceDeviceFindManyArgs, request.query);
    const results = await this.service.findDatasourceDevices(params.id, {
      ...query,
      select: {
        asset: {
          select: {
            id: true,
          },
        },

        created: true,
        datasourceId: true,
        id: true,
        isDeleted: true,
        isLocked: true,
        lastReportSent: true,
        lastReportTime: true,
        name: true,
        reportNumber: true,
        updated: true,
        updatedBy: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/datasourceDevices")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectDatasourceDevices(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: DatasourceDeviceWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      datasourceDevices: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/datasourceDevices")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateDatasourceDevices(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: DatasourceDeviceWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      datasourceDevices: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/datasourceDevices")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectDatasourceDevices(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: DatasourceDeviceWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      datasourceDevices: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/exception")
  @ApiNestedQuery(ExceptionFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Exception",
    action: "read",
    possession: "any",
  })
  async findException(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<Exception[]> {
    const query = plainToClass(ExceptionFindManyArgs, request.query);
    const results = await this.service.findException(params.id, {
      ...query,
      select: {
        asset: {
          select: {
            id: true,
          },
        },

        created: true,
        exceptionEnd: true,
        exceptionReason: true,
        exceptionStart: true,
        exceptionType: true,
        id: true,
        updated: true,
        updatedBy: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/exception")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectException(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: ExceptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      exception: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/exception")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateException(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: ExceptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      exception: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/exception")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectException(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: ExceptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      exception: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/ipAddress")
  @ApiNestedQuery(IpAddressFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "IpAddress",
    action: "read",
    possession: "any",
  })
  async findIpAddress(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<IpAddress[]> {
    const query = plainToClass(IpAddressFindManyArgs, request.query);
    const results = await this.service.findIpAddress(params.id, {
      ...query,
      select: {
        asset: {
          select: {
            id: true,
          },
        },

        assetNetworkDetails: {
          select: {
            id: true,
          },
        },

        created: true,
        dnsName: true,
        id: true,
        ip: true,
        isPrimary: true,
        subnetPurpose: true,
        typeField: true,
        updated: true,
        updatedBy: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/ipAddress")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectIpAddress(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: IpAddressWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      ipAddress: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/ipAddress")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateIpAddress(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: IpAddressWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      ipAddress: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/ipAddress")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectIpAddress(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: IpAddressWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      ipAddress: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/maintenanceWindow")
  @ApiNestedQuery(MaintenanceWindowFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "MaintenanceWindow",
    action: "read",
    possession: "any",
  })
  async findMaintenanceWindow(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<MaintenanceWindow[]> {
    const query = plainToClass(MaintenanceWindowFindManyArgs, request.query);
    const results = await this.service.findMaintenanceWindow(params.id, {
      ...query,
      select: {
        asset: {
          select: {
            id: true,
          },
        },

        created: true,
        id: true,
        maintWindowAvailableDayOfWeek: true,
        maintWindowAvailableMonths: true,
        maintWindowAvailableWeeksOfMonth: true,
        maintWindowCloseTime: true,
        maintWindowLastInside: true,
        maintWindowLevelOfSupport: true,
        maintWindowOpenTime: true,
        updated: true,
        updatedBy: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/maintenanceWindow")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectMaintenanceWindow(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: MaintenanceWindowWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      maintenanceWindow: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/maintenanceWindow")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateMaintenanceWindow(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: MaintenanceWindowWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      maintenanceWindow: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/maintenanceWindow")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectMaintenanceWindow(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: MaintenanceWindowWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      maintenanceWindow: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/operationsCalendar")
  @ApiNestedQuery(OperationsCalendarFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "OperationsCalendar",
    action: "read",
    possession: "any",
  })
  async findOperationsCalendar(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<OperationsCalendar[]> {
    const query = plainToClass(OperationsCalendarFindManyArgs, request.query);
    const results = await this.service.findOperationsCalendar(params.id, {
      ...query,
      select: {
        asset: {
          select: {
            id: true,
          },
        },

        changeCoordinator: true,
        changeManager: true,
        changeRequest: true,

        contact: {
          select: {
            id: true,
          },
        },

        created: true,
        developmentManager: true,
        id: true,
        lastPatched: true,
        locked: true,
        lockedBy: true,
        note: true,

        operationsCalendarStatus: {
          select: {
            id: true,
          },
        },

        projectManager: true,
        reasonCode: true,
        scheduled: true,
        scheduledBy: true,
        serviceId: true,
        technicalLead: true,
        updated: true,
        updatedBy: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/operationsCalendar")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectOperationsCalendar(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: OperationsCalendarWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      operationsCalendar: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/operationsCalendar")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateOperationsCalendar(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: OperationsCalendarWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      operationsCalendar: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/operationsCalendar")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectOperationsCalendar(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: OperationsCalendarWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      operationsCalendar: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/rebootWindow")
  @ApiNestedQuery(RebootWindowFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "RebootWindow",
    action: "read",
    possession: "any",
  })
  async findRebootWindow(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<RebootWindow[]> {
    const query = plainToClass(RebootWindowFindManyArgs, request.query);
    const results = await this.service.findRebootWindow(params.id, {
      ...query,
      select: {
        asset: {
          select: {
            id: true,
          },
        },

        created: true,
        id: true,
        rebootWindowAvailableDayOfWeek: true,
        rebootWindowAvailableMonths: true,
        rebootWindowAvailableWeeksOfMonth: true,
        rebootWindowCloseTime: true,
        rebootWindowOpenTime: true,
        updated: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/rebootWindow")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectRebootWindow(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: RebootWindowWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      rebootWindow: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/rebootWindow")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateRebootWindow(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: RebootWindowWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      rebootWindow: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/rebootWindow")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectRebootWindow(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: RebootWindowWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      rebootWindow: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/subMgmtChangeLog")
  @ApiNestedQuery(SubMgmtChangeLogFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "SubMgmtChangeLog",
    action: "read",
    possession: "any",
  })
  async findSubMgmtChangeLog(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<SubMgmtChangeLog[]> {
    const query = plainToClass(SubMgmtChangeLogFindManyArgs, request.query);
    const results = await this.service.findSubMgmtChangeLog(params.id, {
      ...query,
      select: {
        action: true,

        asset: {
          select: {
            id: true,
          },
        },

        bigfixRequest: {
          select: {
            id: true,
          },
        },

        created: true,
        hostname: true,
        id: true,
        patchChannelIncludeList: true,

        subMgmtChangeLogStatus: {
          select: {
            id: true,
          },
        },

        updated: true,
        updatedBy: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/subMgmtChangeLog")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectSubMgmtChangeLog(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: SubMgmtChangeLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      subMgmtChangeLog: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/subMgmtChangeLog")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateSubMgmtChangeLog(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: SubMgmtChangeLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      subMgmtChangeLog: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/subMgmtChangeLog")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectSubMgmtChangeLog(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: SubMgmtChangeLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      subMgmtChangeLog: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/tssChangeLog")
  @ApiNestedQuery(TssChangeLogFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "TssChangeLog",
    action: "read",
    possession: "any",
  })
  async findTssChangeLog(
    @common.Req() request: Request,
    @common.Param() params: AssetWhereUniqueInput
  ): Promise<TssChangeLog[]> {
    const query = plainToClass(TssChangeLogFindManyArgs, request.query);
    const results = await this.service.findTssChangeLog(params.id, {
      ...query,
      select: {
        action: true,
        applyOn: true,
        applyOnNextScheduledMaintWindow: true,

        asset: {
          select: {
            id: true,
          },
        },

        bigfixRequest: {
          select: {
            id: true,
          },
        },

        created: true,
        id: true,
        remediationWindowHours: true,

        tssChangeLogStatus: {
          select: {
            id: true,
          },
        },

        tssIncludeList: true,
        updated: true,
        updatedBy: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tssChangeLog")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async connectTssChangeLog(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: TssChangeLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tssChangeLog: {
        connect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tssChangeLog")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async updateTssChangeLog(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: TssChangeLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tssChangeLog: {
        set: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tssChangeLog")
  @nestAccessControl.UseRoles({
    resource: "Asset",
    action: "update",
    possession: "any",
  })
  async disconnectTssChangeLog(
    @common.Param() params: AssetWhereUniqueInput,
    @common.Body() body: TssChangeLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tssChangeLog: {
        disconnect: body,
      },
    };
    await this.service.updateAsset({
      where: params,
      data,
      select: { id: true },
    });
  }
}
